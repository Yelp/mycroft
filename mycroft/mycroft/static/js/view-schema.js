(function() {
    var app = angular.module('viewSchema', []);

    "use strict";
    app.controller('ViewSchemaController', ['$scope', '$http', '$location', '$window',
        function($scope, $http, $location, $window) {

        $scope.schemaFilter = {};

        // Keep track of promises and errors for each schema file download
        $scope.schemaEndpointToError = {};
        $scope.schemaEndpointToPromises = {};

        // We'll preserve any errors we get when trying to list schemas
        $scope.listSchemaError = false;

        // Initiate a promise for the list of schemas
        $scope.listSchemaPromise = $http.get('/v1/schema').success(function (data) {
            $scope.rawSchemaResponse = data;
            $scope.unrolledSchemas = unrollSchemas(data);
            $scope.listSchemaPromise = null;
            $scope.listSchemaError = false;
        }).error(function (errorData) {
            $scope.listSchemaPromise = null;
            $scope.listSchemaError = errorData;
        });

        /**
         * Given a schema response object (from the /v1/schema end-point), this
         * function will unroll the contained the object into a list of schemas.
         *
         * @param {schema response object} schemaResponse - from the /v1/schema end-point
         * @return {array} unrolledSchemas - an array of schema objects with {logName, version}
         */
        function unrollSchemas(schemaResponse) {
            if (!schemaResponse){
                return null;
            }
            var unrolledSchemas = [];
            schemaResponse.schemas.forEach(function (schema) {
                schema.versions.forEach(function (version) {
                    var unrolledSchema = {
                        logName: schema.log_name,
                        version: version
                    };
                    unrolledSchemas.push(unrolledSchema);
                });
            });
            return unrolledSchemas;
        }

        $scope.getSchemaEndpoint = function (schema){
            return '/v1/schema/' + schema.logName + '/' + schema.version;
        };

        /**
         * Direct the browser to download a particular schema's file.
         *
         * A temporary link to the file is generated by calling the schema
         * end-point, and the browser is redirected to that temporary link.
         *
         * @param {schema object} schema - object representing the schema to download.
         *
         * There is no return value - instead, this function may modify window.location
         */
        $scope.downloadSchema = function (schema){
            var endpoint = $scope.getSchemaEndpoint(schema);
            $scope.schemaEndpointToPromises[endpoint] = $http.get(endpoint).success(function (data) {
                // Redirect the browser to the data file URL so that it can be downloaded
                $window.location = data.url;
                // Delete unused keys from the map instead of just setting them to false;
                // this will take less memory, and keep the semantics consistent
                delete $scope.schemaEndpointToPromises[endpoint];
                delete $scope.schemaEndpointToError[endpoint];
            }).error(function (errorData) {
                delete $scope.schemaEndpointToPromises[endpoint];
                $scope.schemaEndpointToError[endpoint] = errorData;
            });
        };

        // Sets up two way binding between URL arguments and the schemaFilter.
        // We want the URL to reflect the filter box.
        $scope.$watch('schemaFilter', function (newSchemaFilter, oldSchemaFilter) {
            if (oldSchemaFilter === newSchemaFilter){
                // newSchemaFilter should be the same as oldSchemaFilter only one time,
                // at initialization. In this case, we should not modify the URL -
                // we want to initialize schemaFilter from the URL, not the other way around.
                // This allows people to open a link with a pre-filled search box.
                return;
            }
            else {
                if (newSchemaFilter.logName || newSchemaFilter.version) {
                    $location.search(newSchemaFilter);
                } else {
                    // Clean up the URL if there is no filter text
                    $location.search({});
                }
        }
        }, true);

        // If the filtered fields change, update the model.
        $scope.$watch(function () { return $location.search(); }, function (newSchemaFilter) {
            // On initialization, the model and the URL might not match. In
            // that case, we should init the model from the URL.
            if ($scope.schemaFilter !== newSchemaFilter){
                $scope.schemaFilter = {
                  logName: newSchemaFilter.logName,
                  version: newSchemaFilter.version
              };
          }
        });

    } ]);

} )();
